// Current pnet_transport does not provide abstractions for ICMPv6
// Echo Request and Reply, as it does for IPv4
// This is a transitional module, meant to be submitted to pnet_transport
// directly.

//extern crate pnet_packet;
use pnet::packet::{icmpv6, PrimitiveValues};


pub mod echo_reply {
    //! abstraction for ICMP "echo reply" packets.
    //!
    //! ```text
    //! 0                   1                   2                   3
    //!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |     Type      |     Code      |          Checksum             |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |           Identifier          |        Sequence Number        |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |     Data ...
    //!  +-+-+-+-+-
    //! ```
    //! [RFC 4443 ยง 4.2]: https://tools.ietf.org/html/rfc4443#section-4.1

    use super::PrimitiveValues;
    use super::icmpv6::{Icmpv6Code, Icmpv6Type};
    use pnet_macros_support::types::*;

    /// Represent the "identifier" field of the ICMP echo reply header.
    #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Identifier(pub u16);

    impl Identifier {
        /// Create an identifier
        pub fn new(val: u16) -> Identifier {
            Identifier(val)
        }
    }

    impl PrimitiveValues for Identifier {
        type T = (u16,);
        fn to_primitive_values(&self) -> (u16,) {
            (self.0,)
        }
    }

    /// Represent the "sequence number" field of the ICMP echo reply header.
    #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SequenceNumber(pub u16);

    impl SequenceNumber {
        /// Create a sequence number
        pub fn new(val: u16) -> SequenceNumber {
            SequenceNumber(val)
        }
    }

    impl PrimitiveValues for SequenceNumber {
        type T = (u16,);
        fn to_primitive_values(&self) -> (u16,) {
            (self.0,)
        }
    }

    /// Enumeration of available ICMPv6 codes for ICMPv6 echo reply packets.
    /// There is actually only
    /// one, since the only valid ICMP code is 0.
    #[allow(non_snake_case)]
    #[allow(non_upper_case_globals)]
    pub mod Icmpv6Codes {
        use super::super::icmpv6::Icmpv6Code;
        /// 0 is the only available ICMP code for "echo reply" ICMP packets.
        pub const NoCode: Icmpv6Code = Icmpv6Code(0);
    }

    /// Represents an ICMP echo reply packet.
    #[packet]
    pub struct EchoReply {
        #[construct_with(u8)]
        icmp_type: Icmpv6Type,
        #[construct_with(u8)]
        icmp_code: Icmpv6Code,
        checksum: u16be,
        identifier: u16be,
        sequence_number: u16be,
        #[payload]
        payload: Vec<u8>,
    }
}


pub mod echo_request {
    //! abstraction for "Echo Request" ICMPv6
    //!
    //! ```text
    //!       0                   1                   2                   3
    //!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |     Type      |     Code      |          Checksum             |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |           Identifier          |        Sequence Number        |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |     Data ...
    //!  +-+-+-+-+-
    //! ```
    //! [RFC 4443 ยง 4.1]: https://tools.ietf.org/html/rfc4443#section-4.1

    use super::PrimitiveValues;
    use super::icmpv6::{Icmpv6Code, Icmpv6Type};
    use pnet_macros_support::types::*;

    /// Represents an identifier field
    #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Identifier(pub u16);

    impl Identifier {
        /// Create an identifier
        pub fn new(val: u16) -> Identifier {
            Identifier(val)
        }
    }

    impl PrimitiveValues for Identifier {
        type T = (u16,);
        fn to_primitive_values(&self) -> (u16,) {
            (self.0,)
        }
    }

    /// Represents a sequence number field
    #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SequenceNumber(pub u16);

    impl SequenceNumber {
        /// Create a sequence number
        pub fn new(val: u16) -> SequenceNumber {
            SequenceNumber(val)
        }
    }

    impl PrimitiveValues for SequenceNumber {
        type T = (u16,);
        fn to_primitive_values(&self) -> (u16,) {
            (self.0,)
        }
    }

    /// Enumeration of available ICMPv6 codes for "echo reply" ICMPv6 packets.
    /// There is actually only one, since the only valid ICMPv6 code is 0.
    #[allow(non_snake_case)]
    #[allow(non_upper_case_globals)]
    pub mod Icmpv6Codes {
        use super::super::icmpv6::Icmpv6Code;
        /// 0 is the only available ICMPv6 code for "Echo Request"
        pub const NoCode: Icmpv6Code = Icmpv6Code(0);
    }

    /// Represents an "echo request" ICMP packet.
    #[packet]
    pub struct EchoRequest {
        #[construct_with(u8)]
        icmp_type: Icmpv6Type,
        #[construct_with(u8)]
        icmp_code: Icmpv6Code,
        checksum: u16be,
        identifier: u16be,
        sequence_number: u16be,
        #[payload]
        payload: Vec<u8>,
    }
}

